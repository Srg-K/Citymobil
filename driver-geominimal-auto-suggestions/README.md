# Сервис автоматизированных геоминималок

## Краткое описание работы сервиса

Данный сервис предназначен для автоматической обработки запросов поступающих от таксисерва 
на рассчет автоматизированных геоминималок. Пользователь на станице города задаёт сумму, которую
планируется потратить на геоминималки за неделю, эти данные попадают в базу данных, после чего 
по расписанию запускается данный сервис и в случае наличия запросов на рассчет производится
рассчет геоминималок. Рассчитанные геоминималки записываются в базу данных, откуда они
подтягиваются в таксисерв. Пользователь видит в таксисерве расситанные геоминималки, 
утверждает их и  активирует, после чего они начинают действовать.

Как рассчитываются геоминималки:
1. Для каждого города выгружаются последние 7-28 дней коэффициенты d2v и views в разрезе часов и гексагонов.
2. Для каждого дня, часа и гексагона итерационным способом находим затраты на геоминималки, подгоняем их к заданной сумме лимитов затрат, и таким образом находим значение порогов d2v и views.
3. С найденными пороговыми значениями запускаем окончательный рассчет.

Как оцениваем затраты на геоминималки (пункт2):
1. Находим гексагоны где в принципе нужно применять мотивацию в данный день недели и час дня.
2. Множество гексагонов делим на ГЕОКЛАСТЕРЫ 
3. Каждый геокластер делим на кластер.
4. В каждом кластере рассчитываем сумму геоминималки.
5. Сглаживаем границы кластеров и преобразуем в GeoJSON
6. Прогнозируем количество поездок в данных кластерах и средний чек
7. Рассчитываем предположительные затраты на геоминималки. 

### Подробное описание (дополняется)
Геоминималки – одна из самых расходных DI-механик. Потенциальные точки оптимизации лежат в сокращении площадей полигонов (чтобы не доплачивать там, где не нужно) и более гранулярной разбивки акций по времени (можно не ставить большой полигон на 3 часа, вместо этого можно прикрыть в каждый из часов один маленький по-настоящему горящий полигон)
Ранее это было операционно сложно, поскольку требовало единой методологии и временного ресурса. В этой документации представлено автоматическое решение, которое позволит оптимизировать затраты на механику Геоминималок

1. Из БД выгружаются агрегированнные данные в разрезе день_недели/час/гексагон_8
2. Для раздачи геоминималок отбираются гексагоны с views > quantile(0.85) и d2v < quantile(0.2)
3. Отобранные гексагоны разбиваются не геокластеры при помощи DBScan(исключительно на признаках широты и долготы).
   Параметр радиуса для DBScan подбирается для каждого региона индивидуально функцией calc_max_dbscan_dist.
4. Для каждого геокластера оцениваем его размер(в количестве полигонов), и если геокластер достаточно большой
   разбиваем его на несколько кластеров поменьше на признаках широты, долготы, среднего клиентского чека.
   Количество кластеров для разбиения находим силуэтным методом.
5. Обрабатываем каждый гексагон в каждом кластере функцией reassign_hexagon_by_neighbors -
   если гексагон кластера А окружают N гексагонов кластера Б, то он перекрашивается в кластер Б - это нужно для
   борьбы с островками одного кластера внутри другого кластера.
6. Обрабатываем каждый гексагон в каждом кластере функцией drop_single_hexagons -
   если гексагон кластера А НЕ окружают N гексагонов кластера А, то он удаляется - это нужно для борьбы с
   островками из 1 гексагона среди пустоты.

## Техническая часть
### Источники данных

#### MySQL segmentation

Прод: db19.stl.msk.city-srv.ru  
Тест: webtest0.stl.msk.city-srv.ru

Таблицы:
geominimal_suggest_request
geominimal_suggest_data

#### Clickhouse main

http://chmain-vip.city-srv.tech:8123

Таблицы:
sandbox.d2v_geo_agg_v2
etl_city_import.order_closed_dist
rt_city_import.tariff1
kafka_city_import.order_price_calculations
etl_city_import.order_closed_dist

### Требуется иметь установленными на локальной машине
* git
* make
* python 3.8
* python virtualenv (https://virtualenv.pypa.io/en/latest/index.html)

## Как запускать
* Склонируйте репозиторий себе
* Выполните `make .env` - содаст пустой `.env` файл для указания кастомных настроек БД
* Отредактируйте файл `.env` - переопределите в нем необходимые настройки
 (дефолтные настройки находятся в `.env.dist`)
* Выполните `make install` - установятся зависимости
* Выполните `make run` - запуск скрипта

## Скрипты
* main.py   - корневой скрипт, запускаемый по расписанию
* utils.py  - функции
* db.py     - коннекшены к БД
* queries.py - тексты SQL запросов
* config_connect.py - получение параметров подключений из переменных окружения

## Используемые пакеты
pandas
pandahouse
h3
numpy
geopandas
sklearn
scikit-learn
Shapely
geodaisy
python-dotenv
logging
sys
gc
datetime
time
warnings
configparser
